diff --git a/search_api_algolia.module b/search_api_algolia.module
index 0dbfa6a..c20cdac 100644
--- a/search_api_algolia.module
+++ b/search_api_algolia.module
@@ -5,4 +5,10 @@
  * Provides an Algolia Search based service class for the Search API.
  */
 
-/* use Drupal\search_api_algolia\Plugin\search_api\backend; */
+/**
+ * Implements hook_search_api_field_type_mapping_alter().
+ */
+function search_api_algolia_search_api_field_type_mapping_alter(array &$mapping) {
+  $mapping['algolia_option'] = 'map';
+
+}
diff --git a/src/Plugin/search_api/backend/SearchApiAlgoliaBackend.php b/src/Plugin/search_api/backend/SearchApiAlgoliaBackend.php
index 4a16a17..2980531 100644
--- a/src/Plugin/search_api/backend/SearchApiAlgoliaBackend.php
+++ b/src/Plugin/search_api/backend/SearchApiAlgoliaBackend.php
@@ -2,6 +2,7 @@
 
 namespace Drupal\search_api_algolia\Plugin\search_api\backend;
 
+use AlgoliaSearch\AlgoliaException;
 use AlgoliaSearch\Client;
 use Drupal\Component\Utility\Unicode;
 use Drupal\Core\Form\FormStateInterface;
@@ -29,6 +30,127 @@ class SearchApiAlgoliaBackend extends BackendPluginBase implements PluginFormInt
   protected $algoliaIndex = NULL;
 
   /**
+   * {@inheritdoc}
+   */
+  public function updateIndex(IndexInterface $index) {
+    $settings = [];
+    try {
+      $this->connect($index);
+      $ag_index = $this->getAlgoliaIndex();
+      if ($searchable = $this->getSearchableAttributes($index)) {
+        $settings['searchableAttributes'] = $searchable;
+      }
+      if ($facets = $this->getFacets($index)) {
+        $settings['attributesForFaceting'] = $facets;
+      }
+      $this->moduleHandler->alter('search_api_algolia_index_settings', $settings, $index);
+      $ag_index->setSettings($settings);
+    }
+    catch (AlgoliaException $algoliaException) {
+      $this->logger->error('Unable to set Algolia settings. Error: %err',
+        ['%err' => $algoliaException->getMessage()]);
+    }
+    catch (\Exception $exception) {
+      $this->logger->error('Unable to set Algolia settings. Error: %err',
+        ['%err' => $exception->getMessage()]);
+    }
+    parent::updateIndex($index);
+  }
+
+  /**
+   * Get a list of search attributes to send to Algolia.
+   *
+   * @param \Drupal\search_api\IndexInterface $index
+   *
+   * @return array|bool
+   */
+  protected function getSearchableAttributes(IndexInterface $index) {
+    $fields = $index->getFields();
+    $attribute_fields = $this->getFieldsHelper()
+      ->filterForPropertyPath($fields, NULL, 'searchable_attribute');
+    if (empty($attribute_fields)) {
+      return FALSE;
+    }
+    $attributes = [];
+    /** @var \Drupal\search_api\Item\FieldInterface $attribute_field */
+    foreach ($attribute_fields as $attribute_field) {
+      // Add attributes based on their selected position in the list.
+      $conf = $attribute_field->getConfiguration();
+      if (empty($conf['field'])) {
+        continue;
+      }
+      $ranking = $conf['ranking'];
+      $attribute = $conf['field'];
+      if ($conf['unordered']) {
+        $attribute = 'unordered(' . $attribute . ')';
+      }
+      if (isset($attributes[$ranking])) {
+        if (is_array($attributes[$ranking])) {
+          $attributes[$ranking][] = $attribute;
+        }
+        // This is the second attribute added at this position, turn it into an array.
+        else {
+          $attributes[$ranking] = [$attributes[$ranking], $attribute];
+        }
+      }
+      else {
+        $attributes[$ranking] = $attribute;
+      }
+    }
+    ksort($attributes);
+    // Convert attributes into a single-dimensional array according to Algolia docs.
+    $attribute_settings = [];
+    foreach ($attributes as $attribute_list) {
+      if (is_array($attribute_list)) {
+        $attribute_settings[] = implode(',', $attribute_list);
+      }
+      else {
+        $attribute_settings[] = $attribute_list;
+      }
+    }
+    if (empty($attribute_settings)) {
+      return FALSE;
+    }
+    return $attribute_settings;
+  }
+
+  /**
+   * Get a list of facets to send to Algolia.
+   *
+   * @param \Drupal\search_api\IndexInterface $index
+   *
+   * @return array|bool
+   */
+  protected function getFacets(IndexInterface $index) {
+    $fields = $index->getFields();
+    $facet_fields = $this->getFieldsHelper()
+      ->filterForPropertyPath($fields, NULL, 'facet_attribute');
+    if (empty($facet_fields)) {
+      return FALSE;
+    }
+    $facets = [];
+    /** @var \Drupal\search_api\Item\FieldInterface $facet_field */
+    foreach ($facet_fields as $facet_field) {
+      $conf = $facet_field->getConfiguration();
+      if (empty($conf['field'])) {
+        continue;
+      }
+      $facet = $conf['field'];
+      if ($conf['filter_only']) {
+        $facet = 'filterOnly(' . $facet . ')';
+      }
+      else if ($conf['searchable']) {
+        $facet = 'searchable(' . $facet . ')';
+      }
+      $facets[] = $facet;
+    }
+    if (empty($facets)) {
+      return FALSE;
+    }
+    return $facets;
+  }
+
+  /**
    * A connection to the Algolia server.
    *
    * @var \AlgoliaSearch\Client
@@ -325,15 +447,12 @@ class SearchApiAlgoliaBackend extends BackendPluginBase implements PluginFormInt
   }
 
   /**
-   * Creates a connection to the Algolia Search server as configured in $this->configuration.
+   * Creates a connection to the Algolia Search server as configured in
+   * $this->configuration.
    */
   protected function connect($index = NULL) {
     if (!$this->getAlgolia()) {
       $this->algoliaClient = new Client($this->getApplicationId(), $this->getApiKey());
-
-      if ($index && $index instanceof IndexInterface) {
-        $this->setAlgoliaIndex($this->algoliaClient->initIndex($index->get('id')));
-      }
     }
   }
 
